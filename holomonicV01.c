#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const tSensors kGyroPort = in1; // gyroscopic sensor port/name

bool doUseGyro = true; // enable gyroscopic sensor
float gyroOffset = 90.0; // degrees CCW from +x axis robot faces at gyro=0

void calibrateGyro()
{
  // completely clear out any previous sensor readings by setting the port to "sensorNone"
  SensorType[kGyroPort] = sensorNone;
  wait1Msec(1000);
  SensorType[kGyroPort] = sensorGyro; // reconfigure as sensorGyro
  wait1Msec(2000); // wait for calibration: ROBOT MUST STAY STILL

  SensorScale[kGyroPort] = 138; // adjust SensorScale to correct the scaling for your gyro
  SensorFullCount[kGyroPort] = 3599; // fix rollover to be "...3598, 3599, 0, 1..."
}

task userDriveHolo() {
  const TVexJoysticks kChY = Ch3; // y-axis joystick channel
  const TVexJoysticks kChX = Ch4; // x-axis joystick channel
  const TVexJoysticks kChR = Ch1; // rotation joystick channel
  const short kDelay = 25; // milliseconds for loop delay
  const ubyte kNumWheels = 4; // number of drive wheels
  const ubyte kNumMotorsPerWheel = 2; // max number of motors per wheel
  const tMotor kNone = tmotorNone; // WAS -1 (WS) used for indicating the lack of an additional motor
  const tMotor kMotorPort[kNumWheels][kNumMotorsPerWheel] = { // drive motor ports/names
    {port3, kNone}, // front-left
    {port9, kNone}, // front-right
    {port4, kNone}, // back-left
    {port8, kNone}  // back-right
  };

  word x,y,r;
  float gyro,radius,theta,a,b,wheelSpeed[kNumWheels],topSpeed;

  while(true) {
    // ==== collect joystick & sensor values ====
    x = vexRT[kChX]; // x component
    y = vexRT[kChY]; // y component
    r = vexRT[kChR]; // rotation
    gyro = gyroOffset + (doUseGyro ? SensorValue[kGyroPort]/10.0 : 0.0); // if using gyro, scale its value to degrees

    // ==== convert joystick values to polar ====
    radius = sqrt(pow(x,2) + pow(y,2)); // r = sqrt(x^2 + y^2)
    theta = atan2(y,x)*180.0/PI; // t = arctan(y/x) [converted from radians to degrees]

    theta -= gyro; // adjust for gyro angle

    // ==== calculate opposite-side speeds ====
    a = (cosDegrees(theta + 90.0) + sinDegrees(theta + 90.0))*radius; // front-left and back-right
    b = (cosDegrees(theta) + sinDegrees(theta))*radius; // front-right and back-left

    // ==== set speeds, including rotation ====
    wheelSpeed[0] = a + r; // front-left
    wheelSpeed[1] = b - r; // front-right
    wheelSpeed[2] = b + r; // back-left
    wheelSpeed[3] = a - r; // back-right

    // ==== normalize speeds ====
    topSpeed = 0.0;
    for(ubyte i=0; i<kNumWheels; i++)
      if(abs(wheelSpeed[i]) > topSpeed)
        topSpeed = abs(wheelSpeed[i]); // find highest desired speed
    if(topSpeed > 127.0)
      for(ubyte i=0; i<kNumWheels; i++)
        wheelSpeed[i] /= topSpeed/127.0; // downscale all speeds so none are above 127

    // ==== update motor powers ====
    for(ubyte i=0; i<kNumWheels; i++) // cycle through all wheels
      for(ubyte j=0; j<kNumMotorsPerWheel; j++) // cycle through all motors for each wheel
        if(kMotorPort[i][j] != kNone) // check existence of motor
          motor[kMotorPort[i][j]] = (word)wheelSpeed[i]; // update motor power

    wait1Msec(kDelay);
  }
}

task main() {
  calibrateGyro();
  startTask(userDriveHolo);

  while(true)
    wait1Msec(100);
}
