#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  gearTrain2,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  startStopButton, sensorTouch)
#pragma config(Sensor, dgtl11, gearTrain1,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  gearMotorEnc,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           gearMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	bool started = false;
	float imeTickCount =  627.2;					// Standard Motor Gearing ticks/revolution (360deg)
	float opticalEncoder = 360;						// ticks per revolution (360deg) 1 tick = 1 deg
  float motorRotationCount = 0;
	float gearTrain1RotationCount = 0;
	float gearTrain2RotationCount = 0;

	float motorRPM = 0;
	float gearTrain1RPM = 0;
	float gearTrain2RPM = 0;

	static unsigned long nLoopStartTime;	// timer control
	static long nLoopTime;

	while(1==1) {
		// wait for start signal or if started for stop signal
	  if(!started) {
	  	//wait for the start signal
	    while(SensorValue(startStopButton) == 0)
	    {
	    	// Looop around waitign for an action
	  	}
			// We only get here if the button got pressed
	  	started = true;
	  	// We need to Zero all the encoders so we get an accurtate count
      resetMotorEncoder(gearMotor);
      SensorValue[gearTrain1] = 0;
  		SensorValue[gearTrain2] = 0;
    }
    else
    {
		clearLCDLine(0);		// Clean LCD Display
		clearLCDLine(1);
    // We are in STARTED MODE - we now run the gearTrain, and count revolutions
    nLoopStartTime = nSysTime;
		motor[gearMotor] = 100;

    	// We wait for the STOP button to be pushed
	    if(started) {
	    	while(SensorValue(startStopButton) == 0)
	      {
	    	   // Loop around waiting for an action
	  	  }
        started = false;
        nLoopTime = nSysTime - nLoopStartTime;
        motor[gearMotor] = 0;		// STOP the motor
        // Now print out the revolutions of each gear train stage
        //Calculate the various rotationcounts
        motorRotationCount = (getMotorEncoder(gearMotor) / imeTickCount);
        gearTrain1RotationCount = ((SensorValue[gearTrain1] / opticalEncoder) * -1 );
        gearTrain2RotationCount = ((SensorValue[gearTrain2] / opticalEncoder) * -1 );

        // Calculate RPM
        motorRPM = (motorRotationCount / (nLoopTime)) * 60000;
        gearTrain1RPM = (gearTrain1RotationCount / (nLoopTime)) * 60000;
        gearTrain2RPM = (gearTrain2RotationCount / (nLoopTime)) * 60000;

  			// Print values to LCD Display - however rememebr the values becoem integers!!
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDString(0, 0, "GM:  ");
				displayLCDString(1, 0, "GT1: ");

				displayLCDNumber(0, 4, motorRotationCount, 2);
				displayLCDNumber(1, 4, gearTrain1RotationCount, 2);
				displayLCDString(1, 8, "GT2: ");
				displayLCDNumber(1, 14, gearTrain2RotationCount, 2);

				// Print real values to debug logger
				writeDebugStream("Final Gear Rotation Values\n");
				writeDebugStreamLine("Motor Revolutions: %2.2f", motorRotationCount);
				writeDebugStreamLine("Gear Train Stage #1 Rotations: %2.4f", gearTrain1RotationCount);
				writeDebugStreamLine("Gear Train Stage #2 Rotations: %2.4f", gearTrain2RotationCount);
				writeDebugStreamLine("Time run: %2.4f", nLoopTime);
				writeDebugStreamLine("Motor RPM: %2.4f", motorRPM);
				writeDebugStreamLine("Motor RPM (from IME): %2.4f", getMotorVelocity(gearMotor));
				writeDebugStreamLine("Gear Train 1 RPM: %2.4f", gearTrain1RPM);
				writeDebugStreamLine("Gear Train 2 RPM: %2.4f", gearTrain2RPM);
			}
    }

    // We need to give it a little bit of time to make sure we register the button
    wait1Msec(1000);
	}
}
